#!/bin/sh /etc/rc.common

START=99
STOP=15

ROOT="${IPKG_INSTROOT:-}"
. "$ROOT/usr/share/passwall/utils.sh"
APP_FILE=${APP_PATH}/app.sh
LOCK_FILE_DIR=/var/lock
RUN_LOCK_FILE=${LOCK_FILE_DIR}/${CONFIG}.lock
ACT_LOCK_FILE=${LOCK_FILE_DIR}/${CONFIG}_action.lock
RUN_LOCK_FD=998
ACT_LOCK_FD=999

[ ! -d "$LOCK_FILE_DIR" ] && mkdir -p $LOCK_FILE_DIR
set_lock() {
	local LOCK_TYPE=$1
	local MODE=$2
	if [ "$LOCK_TYPE" = "ACT" ]; then
		FD=$ACT_LOCK_FD
		FILE=$ACT_LOCK_FILE
	else
		FD=$RUN_LOCK_FD
		FILE=$RUN_LOCK_FILE
	fi
	eval "exec $FD>\"$FILE\""
	if [ "$MODE" = "WAIT" ]; then
		flock -x $FD
	else
		flock -xn $FD
	fi
}

unset_lock() {
	local LOCK_TYPE=$1
	if [ "$LOCK_TYPE" = "ACT" ]; then
		flock -u $ACT_LOCK_FD 2>/dev/null
		eval "exec $ACT_LOCK_FD>&-"
		rm -f "$ACT_LOCK_FILE"
	else
		flock -u $RUN_LOCK_FD 2>/dev/null
		eval "exec $RUN_LOCK_FD>&-"
		rm -f "$RUN_LOCK_FILE"
	fi
}

unlock() {
	local LOCK_TYPE=$1; shift
	local LOCK_FILE
	[ "$LOCK_TYPE" = "ACT" ] && LOCK_FILE="$ACT_LOCK_FILE" || LOCK_FILE="$RUN_LOCK_FILE"
	local failcount=1
	while [ "$failcount" -le 10 ]; do
		if [ -f "$LOCK_FILE" ]; then
			if flock -xn "$LOCK_FILE" -c "rm -f $LOCK_FILE" 2>/dev/null; then
				break
			fi
			failcount=$((failcount + 1))
			sleep 1s
			[ "$failcount" -ge 10 ] && unset_lock "$LOCK_TYPE"
		else
			break
		fi
	done
}

boot_func() {
	local delay=$(uci -q get ${CONFIG}.@global_delay[0].start_delay || echo 1)
	if [ "$delay" -gt 0 ]; then
		echolog "执行启动延时 $delay 秒后再启动!"
		sleep $delay
	fi
	restart
	# Use in hotplug.d
	touch ${LOCK_FILE_DIR}/${CONFIG}_ready.lock
}

boot() {
	boot_func >/dev/null 2>&1 &
}

start() {
	eval "exec $ACT_LOCK_FD>\"$ACT_LOCK_FILE\""
	if ! flock -xn $ACT_LOCK_FD; then
		echolog "其他操作正在运行, 退出启动操作."
		exit 0
	fi
	eval "exec $ACT_LOCK_FD>&-"
	set_lock "RUN"
	if [ $? -ne 0 ]; then
		echolog "启动进程已在运行，不重复运行."
		exit 0
	fi
	( eval "exec $ACT_LOCK_FD>&-" ; $APP_FILE start )
}

stop() {
	set_lock "ACT" "WAIT"
	( eval "exec $ACT_LOCK_FD>&- $RUN_LOCK_FD>&-" ; $APP_FILE stop )
	rm -f "$RUN_LOCK_FILE"
	unlock "ACT"
}

restart() {
	set_lock "ACT"
	[ $? -ne 0 ] && echolog "其他操作正在运行，退出重启操作." && exit 0
	( eval "exec $ACT_LOCK_FD>&- $RUN_LOCK_FD>&-" ; $APP_FILE stop )
	rm -f "$RUN_LOCK_FILE"
	( eval "exec $ACT_LOCK_FD>&-" ; $APP_FILE start )
	unlock "ACT"
}

reload() {
	echo "Warning: This service does not support configuration reloading"
	echo "Performing full restart instead..."
	restart
}
